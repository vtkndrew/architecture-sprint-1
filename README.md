### Задание 1

1. Для создания микрофронтендов в проекте Mesto я выбрал фреймворк Webpack Module Federation. Мой выбор пал именно на этот фреймворк, потому что мне кажется, что нету какой-то необходимости в выборе разных фронтенд-фреймворков для разных микрофронтов в этом проекте. На сколько я понял из курса — в такой ситуации лучше использовать Webpack Module Federation, чтобы удобнее шарить общие зависимости, и использовать одну и ту же версию реакта для всех микрофронтов.

1. В проекте я выделил несколько микрофронтов, используя подход DDD:
   - **Микрофронтенд host** — хост приложение страницы
     - вся работа с авторизацией и защищёнными роутами будет в нём
     - по нужному роуту и в нужных местах вёрстки будут отображаться нужные MF
     - а также в нём будет создаваться экземпляр класса EventBus, чтобы все консьюмеры смогли подписаться на нужные им данные, и обновляли их у себя. Например, инфо о юзере
     - основной каркас страницы (хедер, футер, контейнер для контента)
     - общие стили и шрифты для страницы
   - **Микрофронтенд users** — работа профилем пользователя (редактирование профиля юзера, загрузка аватарки, изменение имени, изменение рода занятия юзера)
   - **Микрофронтенд photos** — работа с фотографиями (отображение списка карточек фотографий, модальное окно с подробной информацией по фото, загрузка, удаление, сбор и учёт лайков)
   - **Микрофронтенд shared-library** — библиотека с общими сущностями, например, для контекста юзера (_это я пока не сделал_, поэтому создал в каждом МФ свой контекст CurrentUserContext.js и кладу туда текущего юзера на основе коллбеков в eventBus)
1. Планирование изменений:
   - мне кажется что для перехода от монолита к микрофронтендам в данном случае лучше переходить в соответствие с паттерном Strangler Fig то есть:
     1. сначала надо создать мф host, в который положить всё приложение, установить необходимые зависимости из CRA, а также адаптировать настройки webpack из CRA. Всё работу с автор
     1. далее создать внутри него [eventBus.js](./frontend/microfrontend/host/src/shared/eventBus.js) в папке shared. Его инстанс будет прокидываться через `props` во все мф
     1. вынести в отдельный мф всё что связано с юзерами(users), согласовать контракт работы с текущим юзером внутри всего приложения посредством шины событий(EventBus). В данном случае, мы создаём сообщение `currentUser` при обновлении информации о текущем юзере. Соответственно все мф в которых им нужна будет инфо о юзере, смогут подписаться на ивент `currentUser` и класть его к себе в контекст. (Это я не смог пока что сделать, но тут ещё есть идея чтобы вынести контекст CurrentUserContext в отдельный мф shared-library, который мы будем подключать во всех мф в которых им нужен юзер, и оборачивать в него всё своё микрофронтенд-приложение. Тогда получать текущего юзера из users будет проще, так как у них будет у всех использоваться один и тот же реакт-контекст, и не придётся это делать через шину событий). А также у нас в приложении есть модальные окна, и нам нужно уметь закрыть все модальные окна во всех приложениях — поэтому я это реализовал на шине событий, то есть когда нам нужно закрыть все окна, то я отсылаю через шину событий ивент `closeAllPopups` и во всех мф есть подписка на него, где закрываются все свои модальные окна
     1. вынести в отдельный мф всё что связано с фото(photos). Все модальные окна фотографий будут лежать теперь в этом отдельном мф. Прикрепляются они к DOM с помощью `React.createPortal`(чтобы не сломать вёрстку). А также у нас есть кнопка "+", по клику на которой мы должны показать модальное окно для загрузки новой фотографии, для этого мы опять используем шину событий, то есть при клике на кнопку отсылаем сообщение `showAddPlacePopup`, а в мф обрабатываем его показывая нужное модальное окно
     1. в будущем возможно команды захотят вынести ещё в отдельный МФ и работу с авторизацией и защищёнными роутами, но в данном случае я такого не сделал, так как показалось что это можно оставить в зоне ответственности host-приложения

#### Файловая структура

Я создал в папке microfrontend отдельный npm-проект, чтобы там описать скрипты для работы с приложением целиком, и не приходилось думать каким образом надо запустить приложения чтобы всё заработало. Внутри самих микрофронтендво я постарался сохранить похожей структуру какая она была в монолите внутри src.

- **в мф host**:
  - webpack.config.js // здесь мы используем `ModuleFederationPlugin` и описываем там 2 remotes: photos и users. А также прописываем в shared: deps из package.json + синглтоном react, react-dom, react-router-dom
  - src
    - blocks // здесь лежат все необходимые css блоки
      - auth-form
      - content
      - footer
      - header
      - login
      - page
      - popup
    - components
      - Footer.js
      - Header.js
      - InfoTooltip.js
      - Login.js
      - Main.js // здесь лежит `<main />` в котором мы подключаем наши МФ `UsersAppLazy` и `PhotosAppLazy` через `React.lazy`
      - ProtectedRoute.js
      - Register.js
    - images
      - close.svg
      - error-icon.svg
      - logo.svg
      - success-icon.svg
    - shared
      - eventBus.js // сам класс шины событий и его инстанс, а также там реализованы функции отписки, чтобы не утекала память при ререндерах в useCallback'ах мы возвращаем функцию, которая отписывается от всех ивентов на которые подписалась раньше
    - utils
      - auth.js // здесь апи для работы с авторизацией: register, login, checkToken
    - vendor
      - fonts
      - normalize.css
    - App.jsx // работа с роутами, хедер, футер, контент, рендер в #root этот компонент
    - index.css // сюда мы импортируем все существующие блоки css в этом МФ
    - index.html
    - index.js
- **в мф photos**:
  - webpack.config.js // здесь мы используем `ModuleFederationPlugin` и описываем там 1 exposes: PhotosApp. А также прописываем в shared: deps из package.json + синглтоном react, react-dom, react-router-dom
  - src
    - blocks // здесь лежат все необходимые css блоки
      - card
      - places
    - components
      - AddPlacePopup.js
      - Card.js
      - ImagePopup.js
      - PopupWithForm.js // его также можно попробовать вынести в shared-library, так как он используется и photos, и в users
    - contexts
      - CurrentUserContext.js // локальный контекст для данных о текущем юзере
    - images
      - delete-icon.svg
      - like-active.svg
      - like-inactive.svg
    - utils
      - api.js // здесь апи для работы с фотографиями: getCardList, addCard, removeCard, changeLikeCardStatus
    - App.jsx
    - index.css // сюда мы импортируем все существующие блоки css в этом МФ
    - index.html
    - index.js
- **в мф users**:
  - webpack.config.js // здесь мы используем `ModuleFederationPlugin` и описываем там 1 exposes: UsersApp. А также прописываем в shared: deps из package.json + синглтоном react, react-dom, react-router-dom
  - src
    - blocks // здесь лежат все необходимые css блоки
      - profile
    - components
      - EditAvatarPopup.js
      - EditProfilePopup.js
      - PopupWithForm.js // его также можно попробовать вынести в shared-library, так как он используется и photos, и в users
    - contexts
      - CurrentUserContext.js // локальный контекст для данных о текущем юзере
    - images
      - add-icon.svg
      - edit-icon.svg
    - utils
      - api.js // здесь апи для работы с данными юзера: getUserInfo, setUserInfo, setUserAvatar
    - App.jsx
    - index.css // сюда мы импортируем все существующие блоки css в этом МФ
    - index.html
    - index.js

#### Как запустить проект

1. Пререквизиты:

   1. Установить node и npm нужных версий:

      - node: `v18.18.2`
      - npm: `9.8.1`

        _если вы используете nvm, то можно просто в корне директории вызвать `nvm use`, и нужные версии автоматически будут выбраны_

   1. Перейти в папку [microfrontend](./frontend/microfrontend/). Работа с приложением будет вестить из неё.

   1. Установить все необходимые зависимости:
      - нужно в папке [microfrontend](./frontend/microfrontend/) выполнить команду `npm run install:all`

1. Запустить все микрофронты одним скриптом:

   - нужно в папке [microfrontend](./frontend/microfrontend/) выполнить команду `npm run start:all`, тогда запустятся в `stmux`([подробнее про stmux](https://github.com/rse/stmux)) все микрофронты в таком порядке:
     1. photos
     1. users
     1. host

   PS чтобы завершить процесс с stmux, нужно нажать комбинацию клавиш: `Ctrl + a + k`

1. Откройте в браузере хост-приложение по урлу http://localhost:8080/ — **так как я реализовал все три уровня проекта, то приложение будет работать как и ожидается**

---

### Задание 2

Ссылка на решение в draw.io: https://drive.google.com/file/d/1Pg9lYisLiwM2mJYR5uBcsmyq_0h_vznK/view?usp=sharing
